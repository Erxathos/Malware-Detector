import sys
from backprop import BackpropTrainerExtended
from pybrain.tools.shortcuts import buildNetwork
from pybrain.datasets import SupervisedDataSet
from pybrain.supervised.trainers import BackpropTrainer
from pybrain.structure.modules import SigmoidLayer
from pybrain.tools.customxml import NetworkWriter
from pybrain.tools.customxml import NetworkReader
import matplotlib.pyplot as plt

# file name of all experiments that was prepared in single file
input_data_file_name = 'input_values'

# optimal number of neurons for our application
neurons_count = 13
# number of trainings on the input dataset
epoch_count = 1000
# column order which will be used to the input of NN as training part
input_data_column_number_list = [4, 5, 3, 8, 9, 10, 11, 12, 13, 14]
# expected values for each experiment in verification part, 0 - not infected, 1 - infected
output_values = [1., 0., 1., 0., 1., 1., 1., 0., 0., 0.,]
# which columns use for verification. Each column - single experiment
verification_data_column_number_list = [0, 1, 2, 6, 7]


def load_data():
    """Load input and verification data in columns list
    """
    columns = []
    with open(input_data_file_name, 'r') as values:
        for v in values:
            d = v.split('\t')
            if columns == []:
                for i in range(len(d)):
                    columns.append([])
            for i in range(len(columns)):
                columns[i].append(float(d[i].strip()))
    return columns

def create_data_set(data):
    """Convert input data to DataSet
    """
    ds = SupervisedDataSet(param_count, 1)
    for i in input_data_column_number_list:
        indata = tuple(data[i])
        outdata = output_values[i]
        ds.addSample(indata,outdata)
    return ds

def train_network(network, data_set):
    """Train network using backpropagation method
    """
    t = BackpropTrainer(network, data_set, verbose=True)
    train_errors = []
    for e in range(epoch_count):
        train_errors.append(t.train())
    #t.testOnData(verbose=True)
    return train_errors

def verify_network(network, data, column_number_list):
    """Verify trained network using verification data
    """
    results = []
    for i in column_number_list:
        results.append(network.activate(data[i]))
    return results


# loads data from input file
input_data = load_data()
# counts number of parameters in input file
param_count = len(input_data[0])
# creates dataset from input data to load in NN
data_set = create_data_set(input_data)

# if .xml file with stored weights of NN provided, use it, else create new NN and train it
if (len(sys.argv) > 1):
    net = NetworkReader.readFrom(sys.argv[1])
else:
    net = buildNetwork(param_count,
                       neurons_count,
                       1,
                       hiddenclass=SigmoidLayer,
                       outclass=SigmoidLayer,
                       bias=True)
    errors = train_network(net, data_set)
    # after creation write weights to .xml file for future use
    NetworkWriter.writeToFile(net, 'trainedNetwork.xml')
    # print graph of learning curve
    plt.xlabel('Epoche')
    plt.ylabel('Train error')
    plt.title('Learning curve')
    plt.plot(range(len(errors)), errors, 'b')
    #plt.axis([0, epoch_count, 0, 0.3])

# verify verificaiton dataset on NN
result = verify_network(net, input_data, verification_data_column_number_list)

# print information about expected\actual values of verification
print(net)    
print(net['in'])
print(net['hidden0'])
print(net['out'])
print(result)
j = 0
total_verify_error = 0
for i in verification_data_column_number_list:
    print("Desired: " + str(output_values[i])\
              + "; Actual: " + str(result[j][0]))
    total_verify_error += abs(output_values[i] - result[j][0])
    j +=1
print("Total verify error:", total_verify_error)
plt.show()
